var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import 'rxjs/add/observable/fromEvent';
import 'rxjs/add/operator/debounceTime';
import 'rxjs/add/operator/filter';
import { ChangeDetectorRef, Directive, ElementRef, Input, Renderer, } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import { HandlePropChanges } from '../shared/handle-prop-changes';
var MzSelectDirective = (function (_super) {
    __extends(MzSelectDirective, _super);
    function MzSelectDirective(elementRef, renderer, changeDetectorRef) {
        var _this = _super.call(this) || this;
        _this.elementRef = elementRef;
        _this.renderer = renderer;
        _this.changeDetectorRef = changeDetectorRef;
        _this.suspend = false;
        return _this;
    }
    MzSelectDirective.prototype.ngOnInit = function () {
        this.initHandlers();
        this.initElements();
        this.handleProperties();
    };
    MzSelectDirective.prototype.ngAfterViewInit = function () {
        this.renderer.invokeElementMethod(this.selectElement, 'material_select');
        this.initOnChange();
        this.listenOptionChanges();
        // Need to be done after view init or else the multi-select are not yet in the DOM
        this.initMultiple();
        this.initFilledIn();
    };
    MzSelectDirective.prototype.ngOnDestroy = function () {
        this.renderer.invokeElementMethod(this.selectElement, 'material_select', ['destroy']);
        this.selectElement.off();
    };
    MzSelectDirective.prototype.initHandlers = function () {
        var _this = this;
        this.handlers = {
            disabled: function () { return _this.handleDisabled(); },
            label: function () { return _this.handleLabel(); },
            placeholder: function () { return _this.handlePlaceholder(); },
        };
    };
    MzSelectDirective.prototype.initElements = function () {
        this.selectElement = $(this.elementRef.nativeElement);
        this.selectContainerElement = $(this.elementRef.nativeElement).parents('.input-field');
        this.labelElement = this.createLabelElement();
    };
    MzSelectDirective.prototype.initFilledIn = function () {
        var _this = this;
        this.checkboxElements = this.selectContainerElement.find(':checkbox');
        this.handlers['filledIn'] = function () { return _this.handleFilledIn(); };
        this.handleFilledIn();
    };
    /**
     * Force NgModel value(s) to be selected correctly on multiple select as NgModel
     * is not supported yet by Angular 2 on multiple select and cause selected values
     * to be out of sync when changing values in Materialize select
     */
    MzSelectDirective.prototype.initMultiple = function () {
        var _this = this;
        if (this.selectElement[0].hasAttribute('multiple')) {
            var selectedOptions_1 = this.selectElement
                .find('option')
                .toArray()
                .filter(function (element) { return element.selected; })
                .map(function (element) { return element.value; });
            // setTimeout is needed to this fix to work
            setTimeout(function () { return _this.selectElement.val(selectedOptions_1); });
            // prevent close on first multi select change
            this.lastOptions = Array.from(this.selectElement[0].children);
        }
    };
    /**
     * Trigger the native change event from select element instead of the JQuery.
     * An issue on Github is open about this problem : https://github.com/Dogfalo/materialize/issues/2843
     * This method should be removed when this issue is revolved.
     */
    MzSelectDirective.prototype.initOnChange = function () {
        var _this = this;
        this.selectElement.on('change', function (event) {
            if (!_this.suspend) {
                _this.suspend = true;
                var customEvent = document.createEvent('CustomEvent');
                customEvent.initCustomEvent('change', true, false, event.target.value);
                _this.renderer.invokeElementMethod(_this.selectElement[0], 'dispatchEvent', [customEvent]);
            }
        });
        // Stop the propagation of change event
        this.selectElement[0].addEventListener('change', function () {
            _this.suspend = false;
        });
    };
    MzSelectDirective.prototype.createLabelElement = function () {
        var labelElement = document.createElement('label');
        labelElement.setAttribute('for', this.id);
        this.renderer.invokeElementMethod(this.selectContainerElement, 'append', [labelElement]);
        return $(labelElement);
    };
    MzSelectDirective.prototype.handleProperties = function () {
        if (this.selectContainerElement.length === 0) {
            console.error('Select with mz-select directive must be place inside a [mz-select-container] tag', this.selectElement);
            return;
        }
        _super.prototype.executePropHandlers.call(this);
        this.selectFirstOption();
    };
    MzSelectDirective.prototype.selectFirstOption = function () {
        var firstOptionElement = this.selectElement.children().first();
        if (firstOptionElement.length > 0
            && this.selectElement.children('option[selected]').length === 0
            && !this.selectElement[0].hasAttribute('multiple')) {
            firstOptionElement[0].setAttribute('selected', 'true');
        }
    };
    MzSelectDirective.prototype.handleDisabled = function () {
        this.renderer.setElementProperty(this.selectElement[0], 'disabled', !!this.disabled);
        this.renderer.invokeElementMethod(this.selectElement, 'material_select');
    };
    MzSelectDirective.prototype.handleLabel = function () {
        if (this.label != null) {
            this.renderer.invokeElementMethod(this.labelElement, 'text', [this.label]);
        }
    };
    MzSelectDirective.prototype.handleFilledIn = function () {
        var _this = this;
        if (this.checkboxElements.length > 0) {
            this.checkboxElements.toArray().forEach(function (checkboxElement) {
                _this.renderer.setElementClass(checkboxElement, 'filled-in', !!_this.filledIn);
            });
        }
    };
    MzSelectDirective.prototype.handlePlaceholder = function () {
        var placeholderElement = this.selectElement.children(':disabled').first();
        // if placeholder element exists
        if (placeholderElement.length > 0) {
            if (this.placeholder) {
                // update existing placeholder element
                this.renderer.invokeElementMethod(placeholderElement, 'text', [this.placeholder]);
            }
            else {
                // remove existing placeholder element
                this.renderer.invokeElementMethod(placeholderElement, 'remove');
                // Force trigger change event since it's not triggered when value change programmatically
                this.renderer.invokeElementMethod(this.selectElement, 'change');
                // Required if we don't want exception "Expression has changed after it was checked." https://github.com/angular/angular/issues/6005
                this.changeDetectorRef.detectChanges();
            }
        }
        else {
            if (this.placeholder) {
                // add placeholder element
                var placeholderText = document.createTextNode(this.placeholder);
                var placeholderOption = document.createElement('option');
                placeholderOption.disabled = true;
                placeholderOption.appendChild(placeholderText);
                this.renderer.invokeElementMethod(this.selectElement, 'prepend', [placeholderOption]);
            }
        }
        this.renderer.invokeElementMethod(this.selectElement, 'material_select');
    };
    MzSelectDirective.prototype.listenOptionChanges = function () {
        var _this = this;
        Observable.fromEvent($(this.selectElement), 'DOMSubtreeModified')
            .debounceTime(100)
            .filter(function (event) {
            var currentOptions = Array.from(event.currentTarget.children);
            if (_this.lastOptions) {
                var prevOptions_1 = Array.from(_this.lastOptions);
                _this.lastOptions = currentOptions;
                if (prevOptions_1.length !== currentOptions.length) {
                    return true;
                }
                else {
                    return currentOptions.some(function (option, index) {
                        return !prevOptions_1[index] || option.textContent !== prevOptions_1[index].textContent;
                    });
                }
            }
            else {
                return !!(_this.lastOptions = currentOptions);
            }
        })
            .subscribe(function (x) { return _this.renderer.invokeElementMethod(_this.selectElement, 'material_select'); });
    };
    return MzSelectDirective;
}(HandlePropChanges));
export { MzSelectDirective };
MzSelectDirective.decorators = [
    { type: Directive, args: [{
                selector: 'select[mzSelect], select[mz-select]',
            },] },
];
/** @nocollapse */
MzSelectDirective.ctorParameters = function () { return [
    { type: ElementRef, },
    { type: Renderer, },
    { type: ChangeDetectorRef, },
]; };
MzSelectDirective.propDecorators = {
    'id': [{ type: Input },],
    'disabled': [{ type: Input },],
    'placeholder': [{ type: Input },],
    'label': [{ type: Input },],
    'filledIn': [{ type: Input },],
};
//# sourceMappingURL=select.directive.js.map